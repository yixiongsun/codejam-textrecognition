extends layout

block content
  h1 Dynamic Text Translator
  p.lead Using Google Cloud Vision API to extract text from video frames.
  a.nav-link(href='/upload') Upload
  video(width="320", height="240",autoplay, playsinline)
  video(id="video",width="320", height="240",autoplay, playsinline)

  script.
    /*
    var mediaConstraints = { video: true };
    const localVideo = document.querySelector('video');

    function randomstring(L) {
    var s = '';
    var randomchar = function() {
    var n = Math.floor(Math.random() * 62);
    if (n < 10) return n; //1-10
    if (n < 36) return String.fromCharCode(n + 55); //A-Z
    return String.fromCharCode(n + 61); //a-z
    }
    while (s.length < L) s += randomchar();
    return s;
    }

    var arrayOfBlobs = [];
    setInterval(function() {
        //arrayOfBlobs.append(nextChunk());
        // NEW: Try to flush our queue of video data to the video element
        appendToSourceBuffer();
    }, 1000);

    // 1. Create a `MediaSource`
    var mediaSource = new MediaSource();

    // 2. Create an object URL from the `MediaSource`
    var url = URL.createObjectURL(mediaSource);

        // 3. Set the video's `src` to the object URL
        var video = document.getElementById("video");
        video.src = url;

        // 4. On the `sourceopen` event, create a `SourceBuffer`
        var sourceBuffer = null;
        mediaSource.addEventListener("sourceopen", function()
        {
            // NOTE: Browsers are VERY picky about the codec being EXACTLY
            // right here. Make sure you know which codecs you're using!
            sourceBuffer = mediaSource.addSourceBuffer("video/webm; codecs=\"opus,vp8\"");

            // If we requested any video data prior to setting up the SourceBuffer,
            // we want to make sure we only append one blob at a time
            sourceBuffer.addEventListener("updateend", appendToSourceBuffer);
        });

        // 5. Use `SourceBuffer.appendBuffer()` to add all of your chunks to the video
        function appendToSourceBuffer() {
            if (
                mediaSource.readyState === "open" &&
                sourceBuffer &&
                sourceBuffer.updating === false && arrayOfBlobs.length > 0
            )
            {
              
                sourceBuffer.appendBuffer(arrayOfBlobs.shift());
            }

            // Limit the total buffer size to 20 minutes
            // This way we don't run out of RAM
            if (
                video.buffered.length &&
                video.buffered.end(0) - video.buffered.start(0) > 1200
            )
            {
                sourceBuffer.remove(0, video.buffered.end(0) - 1200)
            }
        }


    function successdata() {

    }

    function onMediaError(e) {
      console.error('media error', e);
    }
    navigator.getUserMedia(mediaConstraints, function(stream) {
    
      document.querySelector('video').srcObject = stream; 
      var mediaRecorder = new MediaRecorder(stream);




      mediaRecorder.ondataavailable = function(blob) {
        var formData = new FormData();
        var file = new File([blob.data], randomstring(15));

        formData.append("file",file)
        $.ajax({
          url: "/api/realtime",
          type: "POST",
          data: formData,
          enctype: 'multipart/form-data',
          processData: false,
          contentType: false,
          success: function(data) {
            let b = new Blob([data])
            var fileReader = new FileReader();
            fileReader.onload = function(event) {
              arrayBuffer = event.target.result;
              arrayOfBlobs.push(arrayBuffer)
            };
            fileReader.readAsArrayBuffer(b);
            //arrayOfBlobs.push(b)
          },
          error: function(e) {
          }
        });
                /*
        var request = new XMLHttpRequest();
        request.open("POST", "/api/realtime");
        request.send(formData);
      };
      mediaRecorder.start(1500);
    }, onMediaError)*/


